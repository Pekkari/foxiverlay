From 0a7396e3cac49bd2c96214b62d03591386d8aa26 Mon Sep 17 00:00:00 2001
From: Antonio Caggiano <antonio.caggiano@collabora.com>
Date: Wed, 20 Sep 2023 18:22:27 +0300
Subject: [PATCH 1/2] virgl: Resource sharing
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Create a virtual function which returns a virgl resource we expect being
an image together with its dimensions.

Signed-off-by: Jos√© Pekkarinen <jose.pekkarinen@foxhound.fi>
Signed-off-by: Antonio Caggiano <antonio.caggiano@collabora.com>
---
 src/venus/vkr_context.c | 28 ++++++++++++++++++++++++++++
 src/venus/vkr_context.h |  3 +++
 src/venus/vkr_image.c   | 38 +++++++++++++++++++++++++++++++++++++-
 src/venus/vkr_image.h   |  7 +++++++
 src/virgl_context.h     |  6 ++++++
 src/vrend_decode.c      | 21 +++++++++++++++++++++
 src/vrend_renderer.h    |  3 +++
 7 files changed, 105 insertions(+), 1 deletion(-)

diff --git a/src/venus/vkr_context.c b/src/venus/vkr_context.c
index 26dfaa0d..53c71916 100644
--- a/src/venus/vkr_context.c
+++ b/src/venus/vkr_context.c
@@ -555,6 +555,32 @@ vkr_context_detach_resource(struct virgl_context *base, struct virgl_resource *r
    mtx_unlock(&ctx->mutex);
 }
 
+static struct virgl_resource *
+vkr_context_resource_lookup_with_dims(struct virgl_context *base, uint32_t res_id, uint32_t *out_width, uint32_t *out_height)
+{
+   struct vkr_context *ctx = (struct vkr_context *)base;
+   struct virgl_resource *res = virgl_resource_lookup(res_id);
+   if (!res)
+      return NULL;
+
+   // Find the memory
+   struct vkr_resource_attachment *att = vkr_context_get_resource(ctx, res_id);
+   if (!att)
+      return NULL;
+
+   struct vkr_device_memory *mem = vkr_context_get_object(ctx, res_id);
+
+   // Find image using that memory
+   struct vkr_image *image = vkr_find_image_with_mem(ctx->object_table, mem->base.handle.device_memory);
+   if (!image)
+      return NULL;
+
+   *out_width = image->extent.width;
+   *out_height = image->extent.height;
+
+   return res;
+}
+
 static void
 vkr_context_destroy(struct virgl_context *base)
 {
@@ -610,6 +636,8 @@ vkr_context_init_base(struct vkr_context *ctx)
    ctx->base.get_fencing_fd = vkr_context_get_fencing_fd;
    ctx->base.retire_fences = vkr_context_retire_fences;
    ctx->base.submit_fence = vkr_context_submit_fence;
+
+   ctx->base.resource_lookup_with_dims = vkr_context_resource_lookup_with_dims;
 }
 
 static uint32_t
diff --git a/src/venus/vkr_context.h b/src/venus/vkr_context.h
index c6f7e11c..710dd655 100644
--- a/src/venus/vkr_context.h
+++ b/src/venus/vkr_context.h
@@ -189,4 +189,7 @@ vkr_context_add_instance(struct vkr_context *ctx,
 void
 vkr_context_remove_instance(struct vkr_context *ctx, struct vkr_instance *instance);
 
+struct vkr_image *
+vkr_find_image(struct hash_table *object_table, VkImage handle);
+
 #endif /* VKR_CONTEXT_H */
diff --git a/src/venus/vkr_image.c b/src/venus/vkr_image.c
index 080b4425..c7bf2695 100644
--- a/src/venus/vkr_image.c
+++ b/src/venus/vkr_image.c
@@ -31,7 +31,9 @@ vkr_dispatch_vkCreateImage(struct vn_dispatch_context *dispatch,
     * situation because the app does not consider the memory external.
     */
 
-   vkr_image_create_and_add(dispatch->data, args);
+   struct vkr_image *img = vkr_image_create_and_add(dispatch->data, args);
+   img->extent = args->pCreateInfo->extent;
+   img->memory = VK_NULL_HANDLE;
 }
 
 static void
@@ -93,6 +95,35 @@ vkr_dispatch_vkGetImageSparseMemoryRequirements2(
                                          args->pSparseMemoryRequirements);
 }
 
+struct vkr_image *
+vkr_find_image(struct hash_table *object_table, VkImage handle)
+{
+   struct hash_entry *entry = NULL;
+   while (entry = _mesa_hash_table_next_entry(object_table, entry)) {
+      struct vkr_object *object = entry->data;
+      if (object->handle.image == handle)
+         return (struct vkr_image *)object;
+   }
+
+   return NULL;
+}
+
+static struct vkr_image *
+vkr_find_image_with_mem(struct hash_table *object_table, VkDeviceMemory handle)
+{
+   struct hash_entry *entry = NULL;
+   while (entry = _mesa_hash_table_next_entry(object_table, entry)) {
+      struct vkr_object *object = entry->data;
+      if (object->type == VK_OBJECT_TYPE_IMAGE) {
+         struct vkr_image *image = (struct vkr_image *)object;
+         if (image->memory == handle)
+            return image;
+      }
+   }
+
+   return NULL;
+}
+
 static void
 vkr_dispatch_vkBindImageMemory(UNUSED struct vn_dispatch_context *dispatch,
                                struct vn_command_vkBindImageMemory *args)
@@ -103,6 +134,11 @@ vkr_dispatch_vkBindImageMemory(UNUSED struct vn_dispatch_context *dispatch,
    vn_replace_vkBindImageMemory_args_handle(args);
    args->ret =
       vk->BindImageMemory(args->device, args->image, args->memory, args->memoryOffset);
+
+   struct vkr_image *image = vkr_find_image(((struct vkr_context *)dispatch->data)->object_table,
+                                            args->image);
+   image->memory = args->memory;
+   image->memory_offset = args->memoryOffset;
 }
 
 static void
diff --git a/src/venus/vkr_image.h b/src/venus/vkr_image.h
index 70a98002..f38af392 100644
--- a/src/venus/vkr_image.h
+++ b/src/venus/vkr_image.h
@@ -10,6 +10,10 @@
 
 struct vkr_image {
    struct vkr_object base;
+
+   VkExtent3D extent;
+   VkDeviceMemory memory;
+   VkDeviceSize memory_offset;
 };
 VKR_DEFINE_OBJECT_CAST(image, VK_OBJECT_TYPE_IMAGE, VkImage)
 
@@ -42,4 +46,7 @@ vkr_context_init_sampler_dispatch(struct vkr_context *ctx);
 void
 vkr_context_init_sampler_ycbcr_conversion_dispatch(struct vkr_context *ctx);
 
+struct vkr_image *
+vkr_find_image(struct hash_table *object_table, VkImage handle);
+
 #endif /* VKR_IMAGE_H */
diff --git a/src/virgl_context.h b/src/virgl_context.h
index 046948d8..8c3a41cd 100644
--- a/src/virgl_context.h
+++ b/src/virgl_context.h
@@ -122,6 +122,12 @@ struct virgl_context {
                        uint32_t flags,
                        uint32_t ring_idx,
                        uint64_t fence_id);
+
+   /* Looks for a vrend_resource in this context, possibly creating one for a vulkan resource */
+   struct virgl_resource *(*resource_lookup_with_dims)(struct virgl_context *ctx,
+                                                       uint32_t res_id,
+                                                       uint32_t *out_width,
+                                                       uint32_t *out_height);
 };
 
 struct virgl_context_foreach_args {
diff --git a/src/vrend_decode.c b/src/vrend_decode.c
index 8bf6de73..03bf2f2b 100644
--- a/src/vrend_decode.c
+++ b/src/vrend_decode.c
@@ -1977,6 +1977,25 @@ static int vrend_decode_ctx_submit_fence(struct virgl_context *ctx,
    return vrend_renderer_create_fence(dctx->grctx, flags, fence_id);
 }
 
+static struct virgl_resource *
+vrend_decode_ctx_resource_lookup_with_dims(struct virgl_context *ctx, uint32_t res_id, uint32_t *out_width, uint32_t *out_height)
+{
+   struct vrend_decode_ctx *dctx = (struct vrend_decode_ctx *)ctx;
+
+   struct virgl_resource *vres = virgl_resource_lookup(res_id);
+   if (!vres)
+      return NULL;
+
+   struct vrend_resource *res = vrend_renderer_ctx_res_lookup(dctx->grctx, res_id);
+   if (!res)
+      return NULL;
+
+   *out_width = res->base.width0;
+   *out_height = res->base.height0;
+
+   return vres;
+}
+
 static void vrend_decode_ctx_init_base(struct vrend_decode_ctx *dctx,
                                        uint32_t ctx_id)
 {
@@ -1996,4 +2015,6 @@ static void vrend_decode_ctx_init_base(struct vrend_decode_ctx *dctx,
    ctx->get_fencing_fd = vrend_decode_ctx_get_fencing_fd;
    ctx->retire_fences = vrend_decode_ctx_retire_fences;
    ctx->submit_fence = vrend_decode_ctx_submit_fence;
+
+   ctx->resource_lookup_with_dims = vrend_decode_ctx_resource_lookup_with_dims;
 }
diff --git a/src/vrend_renderer.h b/src/vrend_renderer.h
index 2aedf50e..53d9a4b7 100644
--- a/src/vrend_renderer.h
+++ b/src/vrend_renderer.h
@@ -213,6 +213,9 @@ struct pipe_resource *
 vrend_renderer_resource_create(const struct vrend_renderer_resource_create_args *args,
                                void *image_eos);
 
+struct vrend_resource *vrend_renderer_ctx_res_lookup(struct vrend_context *ctx,
+                                                     int res_handle);
+
 int vrend_create_surface(struct vrend_context *ctx,
                          uint32_t handle,
                          uint32_t res_handle, uint32_t format,
-- 
2.41.0

